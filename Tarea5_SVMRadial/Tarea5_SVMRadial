from sklearn import datasets
from sklearn.model_selection import train_test_split, GridSearchCV, cross_val_score
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVC
from sklearn.metrics import classification_report, confusion_matrix
import matplotlib.pyplot as plt
import numpy as np


class SVMRadialAI:
     # Rango de búsqueda por defecto
    def __init__(self, C_values=None, gamma_values=None):
        self.C_values = C_values if C_values is not None else [0.1, 1, 10]
        self.gamma_values = gamma_values if gamma_values is not None else ['scale', 0.1, 1]
        self.best_model = None

    #realiza busquedas con GrindSeachCV
    def entrenar(self, X_train, y_train):
        print(" Buscando mejores hiperparámetros con Grid Search...")
        param_grid = {'C': self.C_values, 'gamma': self.gamma_values, 'kernel': ['rbf']}
        grid = GridSearchCV(SVC(), param_grid, cv=5, n_jobs=-1)
        grid.fit(X_train, y_train)

        self.best_model = grid.best_estimator_
        print(f" Mejor combinación encontrada: C={grid.best_params_['C']}, gamma={grid.best_params_['gamma']}")

        # Validación cruzada con el mejor modelo
        print("Evaluando con validación cruzada...")
        scores = cross_val_score(self.best_model, X_train, y_train, cv=5)
        print(f"Precisión promedio CV: {scores.mean():.3f}")

    #predice con el mejor modelo enconrirado
    def predecir(self, X_test): 
        if self.best_model is None:
            raise Exception(" El modelo no ha sido entrenado. Llama primero a 'entrenar()'.")
        return self.best_model.predict(X_test)

    #evalua el modelo en los datos de prueba
    def evaluar(self, X_test, y_test):#
        y_pred = self.predecir(X_test)
        print("\n REPORTE FINAL DE CLASIFICACIÓN:")
        print(confusion_matrix(y_test, y_pred))
        print(classification_report(y_test, y_pred))
    #visualiza las fronyeras de desicion del modelo en 2D
    def visualizar(self, X, y):
        if X.shape[1] != 2:
            print("Solo se puede visualizar en 2D.")
            return

        plt.figure(figsize=(8, 6))
        X1, X2 = np.meshgrid(
            np.linspace(X[:, 0].min() - 1, X[:, 0].max() + 1, 500),
            np.linspace(X[:, 1].min() - 1, X[:, 1].max() + 1, 500)
        )
        Z = self.best_model.predict(np.c_[X1.ravel(), X2.ravel()]).reshape(X1.shape)
        plt.contourf(X1, X2, Z, cmap=plt.cm.coolwarm, alpha=0.3)
        plt.scatter(X[:, 0], X[:, 1], c=y, cmap=plt.cm.coolwarm, edgecolors='k')
        plt.title("Regiones de decisión SVM-RBF (mejor modelo encontrado)")
        plt.xlabel("Característica 1")
        plt.ylabel("Característica 2")
        plt.show()
        
if __name__ == "__main__":
    print("Ejemplo: Clasificación de Iris ")

    # Cargar dataset Iris
    iris = datasets.load_iris()
    X = iris.data[:, :2]
    y = iris.target

    # Dividir en entrenamiento y prueba
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    # Escalar
    scaler = StandardScaler()
    X_train = scaler.fit_transform(X_train)
    X_test = scaler.transform(X_test)

    # Entrenar y evaluar modelo
    svm_ai = SVMRadialAI()
    svm_ai.entrenar(X_train, y_train)
    svm_ai.evaluar(X_test, y_test)
    svm_ai.visualizar(X_train, y_train)
